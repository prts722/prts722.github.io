[{"content":" 新的项目开始搭建，这次的前端使用的是Vue3,所以肯定需要配置NodeJS，下面是根据指导老师及个人理解所写成的笔记，有直接生成的部分这篇的观感可能一般\n1、开发环境安装与配置 1.1、安装 Node.js 1.1.1、下载并安装 官方下载: https://nodejs.org/download/release/\nAutomatically install the necessary tools。Note that this will also install Chocolatey。The script will pop-up in a new window after the installation completes。\n如果选中该选项，在安装NodeJS时，会自动安装一些工具，如：Python和Visual Studio的构建工具Chocolatey，安装完Chocolatey以后，会弹出PowerShell进行安装Python、Visual Studio等。\n1.1.2、测试 打开 cmd 窗口\n查看版本\n1 2 3 4 ## 查看已安装的 NodeJS 的版本 node -v ## 查看 NodeJS 自带的 npm （Node Package Manager：包管理工具）的版本 npm -v 1.2、配置Node.js 1.2.1、修改全局目录 修改npm命令全局模块安装目录和全局缓存目录。\n1.2.1.1、创建目录 在nodejs的安装目录下创建 node_cache 和 node_global 两个文件夹。\n1.2.1.2、修改目录权限 按下图修改 node_cache 和 node_global 两个文件夹的权限。\n1.2.1.3、修改npm的默认目录 修改npm命令的默认全局模块安装目录和全局缓存目录\n1 2 3 4 ## 设置全局模块安装路径 npm config set prefix \u0026#34;D:\\nodejs\\node_global\u0026#34; ## 设置全局缓存存放路径 npm config set cache \u0026#34;D:\\nodejs\\node_cache\u0026#34; 1.2.1.4、配置环境变量 1.2.2、配置镜像源 1 2 ## 配置镜像源（仓库的地址） npm config set registry=https://registry.npmmirror.com/ 1.2.3、安装包管理工具 常用的包管理工具：npm、cnpm、yarn\n1 2 3 4 ## 安装 cnpm npm install cnpm -g ## 安装 yarn npm install yarn -g 1.3 npm / cnpm 命令 1.3.1 查看帮助信息 1 2 3 4 5 6 7 8 9 10 11 12 ## 查看npm的版本号 npm –v ## 查看npm命令的帮助信息 npm -h npm --help ## 查看npm子命令的帮助信息 npm 子命令名 -h npm 子命令名 --help ## 显示所有命令的使用信息 npm -l ## 在浏览器中打开指定命令的帮助网页 npm help 子命令名 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 #### 1.3.2、子命令 语法：npm 子命令名 access, adduser, audit, bin, bugs, \u0026lt;font color=\u0026#34;blue\u0026#34;\u0026gt;cache\u0026lt;/font\u0026gt;, ci, completion, \u0026lt;font color=\u0026#34;red\u0026#34;\u0026gt;config\u0026lt;/font\u0026gt;, dedupe, deprecate, diff, dist-tag, docs, doctor, edit, exec, explain, explore, find-dupes, fund, \u0026lt;font color=\u0026#34;red\u0026#34;\u0026gt;get\u0026lt;/font\u0026gt;, \u0026lt;font color=\u0026#34;blue\u0026#34;\u0026gt;help\u0026lt;/font\u0026gt;, hook, \u0026lt;font color=\u0026#34;red\u0026#34;\u0026gt;init, install\u0026lt;/font\u0026gt;, install-ci-test, install-test, link, ll, login, logout, ls, org, outdated, owner, pack, ping, pkg, \u0026lt;font color=\u0026#34;blue\u0026#34;\u0026gt;prefix\u0026lt;/font\u0026gt;, profile, prune, publish, query, rebuild, repo, restart, root, run-script, \u0026lt;font color=\u0026#34;red\u0026#34;\u0026gt;search, set\u0026lt;/font\u0026gt;, set-script, shrinkwrap, star, stars, start, stop, team, test, token, \u0026lt;font color=\u0026#34;red\u0026#34;\u0026gt;uninstall\u0026lt;/font\u0026gt;, unpublish, unstar, \u0026lt;font color=\u0026#34;blue\u0026#34;\u0026gt;update\u0026lt;/font\u0026gt;, \u0026lt;font color=\u0026#34;blue\u0026#34;\u0026gt;version\u0026lt;/font\u0026gt;, view, whoami 1.3.3、配置管理 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 ######### npm 配置文件管理 ######### ## npm的配置文件默认在 C:\\Users\\用户名\\.npmrc ## 查看 npm 配置文件路径 npm config get userconfig ## 打开 npm 的配置文件 npm config edit ######### npm 配置管理 ######### ## 获取所有参数的当前配置 npm config ls 【--json】 npm config ll 【--json】 npm config la 【--json】 npm config list 【--json】 ## 获取指定参数当前配置的值 npm config get 【参数名【参数名 ...】 ## 设置指定参数的值 npm config set 参数名=参数值 【参数名=参数值 ...】 ## 删除指定的参数配置 npm config delete 参数名【参数名 ... 】 ## 设置全局模块安装路径 注意：等于号两边不能有空格 npm config set prefix=\u0026#34;全局安装路径\u0026#34; ## 设置全局缓存存放路径 npm config set cache=\u0026#34;安装组件时使用的缓存路径\u0026#34; 1.3.4、镜像管理 1 2 3 4 5 ######### npm 镜像管理 ######### ## 查看当前使用的镜像源地址 npm 【config】 get registry ## 设置镜像源地址：npm config set registry=https://registry.npmmirror.com/ npm 【config】 set registry = 镜像地址 1.3.5、包管理 1.3.5.1、命令 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 ######### npm管理包 ######### ## 查询仓库中的模块 npm search 模块名 ## 安装模块：install 也可以简写为 i npm install 模块名【@版本号】 【-g | -S | -D】【--registry=临时源地址】 ## 卸载模块 npm uninstall 模块名【@版本号】 【-g | -S | -D】 #### view : 查看包相关信息 #### 别名：info、show、v ## 查看指定包的依赖关系 npm view 包名 dependencies ## 查看指定包的最新版本号 npm view 包名 version ## 查看指定包的所有历史版本号 npm view 包名 versions ## 查看指定包的详细信息 npm view 包名 ## 检查模块是否已经过时 npm outdated 模块名 1.3.5.1.1、命令参数 1 2 3 4 5 6 7 8 9 10 ##表示安装到全局目录 或 卸载全局目录下的包 -g , --global ## 表示安装（或卸载）的包会写入（或删除）package.json文件中的dependencies（**生产阶段的依赖**） -S , --save ## 表示安装（或卸载）的包会写入（或删除）package.json文件中的devDependencies （开发阶段的依赖） -D , --save-dev ## 表示安装（或卸载）的包会写入（或删除）package.json文件中optionalDependencies（可选阶段的依赖） -O , --save-optional ## 安装指定版本的模块，而不是使用兼容的版本方式 -E , --save-exact 1.3.5.1.2、版本号 版本号的使用方式（假设当前最新版本号是 1.1.0 ）\n1 2 3 4 5 6 ## 兼容模块新发布的补丁版本 ~1.1.0 、 1.1.x 、 1.1 ## 兼容模块新发布的小版本、补丁版本 ^1.1.0 、 1.x 、 1 ## 兼容模块新发布的大版本、小版本、补丁版本 * 、 x 1.3.6、项目管理 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 \\######### npm管理项目 ######### \\## 初始化项目 npm init 【-y】 npm create 【-y】 \\## 查看项目中模块所在的目录 npm root \\## 查看全局安装的模块所在目录 npm root –g \\## 查看本地已安装模块的清单列表 npm list 或者 npm ls \\## 查看本地已安装的包名的详细信息 npm ls 包名 npm list 包名 \\## 查看指定包的来源地址 npm view 包名 repository.url \\## 清除项目中没有被使用的包 npm prune \\## 运行项目中的测试脚本 npm test \\## 运行指定的脚本 npm run 脚本名 \\## 启动模块 npm start 模块名 【--参数】 \\## 该命令会在package.json文件中scripts的start字段中，可以自定义命令来配置一个服务器环境和安装一系列的必要程序 \\## 如 \u0026#34;scripts\u0026#34;: { \u0026#34;start\u0026#34;: \u0026#34;gulp -ws\u0026#34; } \\## 此时在cmd中输入npm start命令相当于执行gulpfile.js文件自定义的watch和server命令。 \\## 如果package.json文件没有设置start，则将直接启动node server.js \\## 停止模块 npm stop 模块名 【--参数】 \\## 重启模块 npm restart 模块名 【--参数】 \\## 测试模块 npm test 模块名 【--参数】 \\## 该命令写在package.json文件scripts的test字段中，可以自定义该命令来执行一些操作 \\## 如 \u0026#34;scripts\u0026#34;: { \u0026#34;test\u0026#34;: \u0026#34;gulp release\u0026#34; }, \\## 此时在cmd中输入npm test命令相当于执行gulpfile.js文件自定义的release命令。 其他命令 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 \\## 清除npm的缓存 npm cache clean \\## 会打开默认浏览器跳转到github中包名的页面 npm repo 包名 \\## 会打开默认浏览器跳转到github中包名的README.MD文件信息 npm docs 包名 \\## 会打开默认浏览器跳转到github中包名的主页 npm home 包名 ","date":"2025-04-01T01:06:00+08:00","image":"https://prts722.github.io/p/%E5%AE%9E%E8%AE%AD%E8%AE%B0%E5%BD%951/%E5%B0%81%E9%9D%A2%E5%9B%BE_hu13173909405452735033.png","permalink":"https://prts722.github.io/p/%E5%AE%9E%E8%AE%AD%E8%AE%B0%E5%BD%951/","title":"实训记录1"},{"content":" 目前可以写各种爬虫脚本来获取需要资源了，下一步就是对爬取的数据进行处理，这样的话何不直接研究一下通过python来处理表格excel表格呢，所以在进行了几天的研究后，\n","date":"2024-05-08T21:34:53+08:00","image":"https://prts722.github.io/p/%E9%80%9A%E8%BF%87pandas%E5%92%8Copenpyxl%E5%AE%9E%E7%8E%B0%E8%A1%A8%E6%A0%BC%E6%93%8D%E4%BD%9C/%E5%B0%81%E9%9D%A2%E5%9B%BE_hu12719021977666565223.png","permalink":"https://prts722.github.io/p/%E9%80%9A%E8%BF%87pandas%E5%92%8Copenpyxl%E5%AE%9E%E7%8E%B0%E8%A1%A8%E6%A0%BC%E6%93%8D%E4%BD%9C/","title":"通过pandas和openpyxl实现表格操作"},{"content":" 在经过爬虫的初学习，反爬问题的出现以及最终的问题解决后，经过最后的整合，终于是写好了一个较为完整的爬虫脚本，可以搜索小说并选择对应的书籍进行下载，最终结果如下：\n【图中所爬取的网站为笔趣阁】\n小说爬虫展示 下面是代码的各部分功能\n获取页面请求 在定义第一个函数前需要导入方法所需要的库，这里我偷懒直接把整个代码所有的库都写进去了\n1 2 3 4 5 6 7 import re import os import json import time import requests from urllib.parse import quote from requests.utils import dict_from_cookiejar 接下来就是定义第一个获取页面源代码的函数了\n1 2 3 4 5 6 7 8 9 10 11 12 # 定义获取源代码函数 def get_response(html_url): # 函数参数(html_url)：要请求的链接（url） # 定义请求头 headers = { \u0026#39;User-Agent\u0026#39;: \u0026#39;Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/122.0.0.0 Safari/537.36 Edg/122.0.0.0\u0026#39; } # 获取小说源代码 html_data = requests.get(url=html_url, headers=headers) # 定义编码格式 html_data.encoding = html_data.apparent_encoding # 返回源代码 return html_data 通过上面代码的调用可以获得一个response=200的返回值，表示已经爬取成功，通过.text方法就可以查看页面源代码\n获取小说各章节链接函数 通过对某一本小说进行页面审查可以获取到该小说每一章节的链接，审查方式之前已经说过这里不再赘述\n1 2 3 4 5 6 7 8 # 定义获取各章节链接的函数 def get_data(html_url_2): # 函数参数(html_url_2)： 小说目录页链接 # 获取目录页源代码 html_data = get_response(html_url_2).text # 提取小说各章节链接 html = re.findall(\u0026#39;\u0026lt;dd\u0026gt;\u0026lt;a href =\u0026#34;(.*?)\u0026#34;\u0026gt;\u0026#39;, html_data) # 返回小说名字和章节链接 return html 获取各章节标题和小说内容函数 和上面获取各章节链接的方法一样，通过页面审查，正则表达式的方法就可以获取到各章节标题和文本内容\n1 2 3 4 5 6 7 8 9 10 11 12 def content(html_url_3): # 参数：小说章节链接 get = get_response(html_url_3) # result = parsel.Selector(get.text) # print(result) # 修改编码格式 # get.encoding = \u0026#34;utf-8\u0026#34; # 提取标题和内容 title = re.findall(\u0026#39;\u0026lt;span class=\u0026#34;title\u0026#34;\u0026gt;(.*?)\u0026lt;/span\u0026gt;\u0026#39;, get.text) result_2 = re.findall(\u0026#39;\u0026lt;div id=\u0026#34;chaptercontent\u0026#34; class=\u0026#34;Readarea ReadAjax_content\u0026#34;\u0026gt;(.*)\u0026lt;br /\u0026gt;\u0026#39;, get.text) # print(title) # print(result_2) return title,result_2 定义搜索函数 这是整个爬虫中唯一不好弄的一部分，该网站的查询界面通过动态渲染的方式加载，导致无法获取到我们所需要的信息，解决方法之前已经说过，这里直接展示代码（过长的部分通过描述代替）\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 def search(word): s_url = f\u0026#39;https://www.c336.icu/user/search.html?q={word}\u0026amp;so=undefined\u0026#39; s_headers = { “请求标头” } s_html = requests.get(url=s_url,headers=s_headers) cookie = s_html.cookies s_cookie = dict_from_cookiejar(cookie) s_html_2 = requests.get(url=s_url, cookies=s_cookie) get_json = json.loads(s_html_2.content) book_name_list = [] book_url_list = [] try: if get_json == 1: print(\u0026#34;\\r没有该小说或请稍后再试\u0026#34;) else: book_url = re.findall(\u0026#39;\u0026#34;url_list\u0026#34;:\u0026#34;(.*?)\u0026#34;,\u0026#39;, s_html_2.text) book_name = re.findall(\u0026#39;\u0026#34;articlename\u0026#34;:\u0026#34;(.*?)\u0026#34;,\u0026#39;, s_html_2.text) # print(book_url) # print(book_name) for new_url in book_url: book_url_list.append(str(new_url).replace(\u0026#34;\\\\\u0026#34;,\u0026#34;\u0026#34; )) for new_book_name in book_name: book_name_list.append(eval(repr(new_book_name).replace(\u0026#39;\\\\\\\\\u0026#39;, \u0026#39;\\\\\u0026#39;))) except(): print(\u0026#34;请稍后再试\u0026#34;) book_dict = dict(zip(book_name_list, book_url_list)) return book_dict 上述方法能完美解决动态渲染问题，同时加入了报错解决以及查询不到小说的处理\n定义保存函数 通过使用os以及with open的写入方法，可以将获取到的小说放入以小说名命名的文件夹当中\n1 2 3 4 5 6 7 8 9 10 11 def save(name, title, result): # 三个参数含义：小说名，章节名，内容 # 判断是否有小说文件夹，如果没有则自动创建 file = \u0026#39;{}\\\\\u0026#39;.format(name) if not os.path.exists(file): os.mkdir(file) # 保存小说内容至文件夹 with open(file + title + \u0026#39;.txt\u0026#39;, mode=\u0026#39;a\u0026#39;, encoding=\u0026#39;utf-8\u0026#39;) as f: f.write(title) f.write(\u0026#39;\\n\u0026#39;) f.write(result) f.write(\u0026#39;\\n\u0026#39;) 所有功能的整合及使用 这里我偷懒没有定义main函数，而是直接将各部分按逻辑连接并实现的功能，并且加入了延时功能防止爬取太快被网站禁止访问\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 # 搜索小说 x = str(input(\u0026#34;请输入小说：\u0026#34;)) n = quote(x,encoding=\u0026#34;utf-8\u0026#34;) request_dict = search(str(n).replace(\u0026#34;,\u0026#34;,\u0026#34;\\n\u0026#34;)) print(\u0026#34;您搜索到的小说结果如下\u0026#34;) # 选择小说 for name in request_dict: print(name) choose_book = input(\u0026#34;请选择要下载的小说：\\n\u0026#34;) if choose_book in request_dict.keys(): num = 1 # 获得对应书籍链接 book_href = \u0026#34;https://www.c336.icu\u0026#34; + request_dict[choose_book] # 爬取目录页，获取各章节链接 book_text_href = get_data(book_href) # 通过for循环对每一个章节链接进行爬取并保存 for text_href in book_text_href: new_href = \u0026#34;https://www.c336.icu\u0026#34; + text_href # print(new_href) text_name, text_result = content(new_href) str_text_name = str(*text_name) str_text_result = str(*text_result).replace(\u0026#34;\u0026lt;br /\u0026gt;\u0026#34;,\u0026#34;\\n\u0026#34;) print(f\u0026#34;正在保存第{num}节\u0026#34;) save(choose_book, str_text_name, str_text_result) num += 1 time.sleep(3) else: print(\u0026#34;没有这本小说\u0026#34;) 最终成果 通过上面的各部分函数间的调度使用，就可以形成完整的小说爬取功能，最后保存下来的小说就会保存在下面的文件夹中（只爬取一些章节作展示） 其他展示 在完成这一整个较为完整项目的同时，还便写了一些较为简单的爬虫作为练手，这里挑选几个放出来\n爬取豆瓣前250电影名 这里使用的是BeautifulSoup4进行内容解析 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 import requests from bs4 import BeautifulSoup # 定义请求头，把程序伪装成浏览器请求，从而实现请求不被阻拦 headers = { \u0026#39;User-Agent\u0026#39;: \u0026#39;Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/121.0.0.0 Safari/537.36\u0026#39; } for start_num in range(0, 250, 25): # 用get方法传入想爬取的链接 response = requests.get(\u0026#39;https://movie.douban.com/top250?start={}\u0026#39;.format(start_num), headers=headers) html = response.text # 获取源代码(不加text获得的是访问回应值) soup = BeautifulSoup(html, \u0026#39;html.parser\u0026#39;) # 用bs解析源代码 all_title = soup.findAll(\u0026#39;span\u0026#39;, attrs={\u0026#39;class\u0026#39;: \u0026#39;title\u0026#39;}) # 查找所需内容 for title in all_title: title_string = title.string if \u0026#39;/\u0026#39; not in title_string: print(title.string) 爬取某电影网站的电影简介 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 import requests import re # 定义请求头 headers = { \u0026#39;User-Agent\u0026#39;: \u0026#39;Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/121.0.0.0 Safari/537.36 Edg/121.0.0.0\u0026#39; } # for 循环遍历每一个内容介绍的链接（也可以使用嵌套循环） for i in range(1, 96): url = \u0026#39;https://ssr1.scrape.center/detail/{}\u0026#39;.format(i) # 需要爬取的链接 cinema_1 = requests.get(url=url, headers=headers) # 抓取信息（源代码） cinema = cinema_1.text # 转成源代码 title = re.findall(\u0026#39;\u0026gt;(.*?)\u0026lt;/a\u0026gt;\u0026#39;, cinema)[0].replace(\u0026#39;\u0026lt;/h2\u0026#39;, \u0026#39;\u0026#39;) # 抓取标题 introduction = re.findall(\u0026#39;\u0026lt;p data-v-63864230=\u0026#34;\u0026#34;\u0026gt;(.*?)\u0026lt;\u0026#39;, cinema, re.S)[0].strip().replace(\u0026#39;。\u0026#39;, \u0026#39;\\n\u0026#39;) # 抓取内容 # 创建txt保存抓取内容 with open(\u0026#39;电影简介\u0026#39; + \u0026#39;.txt\u0026#39;, mode=\u0026#39;a\u0026#39;, encoding=cinema_1.apparent_encoding)as f: f.write(str(title)) # 写入电影名 f.write(\u0026#39;\\n\u0026#39;) # 空行 f.write(str(introduction)) # 写入简介内容 f.write(\u0026#39;\\n\u0026#39;) # 空行 f.write(\u0026#39;\\n\u0026#39;) # 打印标题 print(title + \u0026#39;保存成功\u0026#39;) ","date":"2024-05-05T01:22:09+08:00","image":"https://prts722.github.io/p/python%E7%88%AC%E8%99%AB%E8%84%9A%E6%9C%AC%E9%A1%B9%E7%9B%AE%E5%B1%95%E7%A4%BA/%E5%B0%81%E9%9D%A2%E5%9B%BE_hu9160276130315547875.png","permalink":"https://prts722.github.io/p/python%E7%88%AC%E8%99%AB%E8%84%9A%E6%9C%AC%E9%A1%B9%E7%9B%AE%E5%B1%95%E7%A4%BA/","title":"Python爬虫脚本项目展示"},{"content":" 在研究了爬虫研究了几天并添加了一些功能够后，我决定增加一个搜索功能，但就在我以为可以按照正常爬取逻辑写代码时，我在搜索结果页面所获取到的却只是一个普通的为加载出来的html页面代码，经过搜索后发现是遇到了动态渲染无法加载的结果，之后在京东购物页面获取商品图时也发现了同样的问题，几经波折后终于是解决了，下面以京东购物为例进行一个经验分享\n问题详情 当我们正常按照流程去进行爬取，获取到的源代码如下图所示： 京东网站下代码如下： 对比后可以发现，我们爬取下来的html代码和网站的不一样，并且我们所需要的商品图链接也没有\n由此可以判定，因为动态渲染导致我们无法获取到需要的信息\n问题解决 研究了很久以后，发现要想解决问题很简单\u0026hellip;..\n按F12打开任务管理器，点击网络,清空内容后刷新页面，让资源重新加载 2.随便审查一张封面图，查看他的链接，在其中截取一部分有代表性的片段 3.在网络中查找刚才截取的片段找到响应商品图的文件夹 4.查看标头获取请求url和请求标头 +5. 将请求url和请求标头分别替换掉代码中的url和headers（请求标头中开头带冒号的几个删除掉否则会报错） 运行后可以发现已经可以获取到需要的结果了，接下来再修改一下审查逻辑并截取拼接后就可以获取到所有的商品图链接，代码如下\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 import requests import re url = \u0026#34;请求url\u0026#34; headers = { \u0026#34;请求标头\u0026#34; } get_request = requests.get(url=url,headers=headers).content.decode(\u0026#34;utf-8\u0026#34;) pdf_href = re.findall(\u0026#39;\u0026#34;img\u0026#34;:\u0026#34;(.*?)\u0026#34;\u0026#39;, get_request) for i in pdf_href: if \u0026#34;babel\u0026#34; in i: pass else: new_href = \u0026#34;https://img14.360buyimg.com/jdcms/s480x480_\u0026#34; + str(i).replace(\u0026#34;\\\\\u0026#34;,\u0026#34;/\u0026#34;) print(new_href) 运行结果如下： 就这样，通过修改两个地方便解决了动态渲染无法获取信息的问题，当然也可以使用Selenium等方法自动化模拟运行浏览器，这里就不多赘述了\n","date":"2024-04-25T23:08:49+08:00","image":"https://prts722.github.io/p/%E7%88%AC%E8%99%AB%E5%AD%A6%E4%B9%A02/%E5%B0%81%E9%9D%A2%E5%9B%BE_hu3082821905081439932.png","permalink":"https://prts722.github.io/p/%E7%88%AC%E8%99%AB%E5%AD%A6%E4%B9%A02/","title":"爬虫学习2"},{"content":" 从今天开始算是正式进入爬虫学习了，前面学会了基础，又搭建了博客以后，开始在网络上找资源，终于算是找到了比较好的教程开始学习爬虫，目前已经能写出基本的简易爬虫，记录一下心得\n写爬虫时最好使用定义函数，将每一部分功能都分到不同的函数中封装起来，需要使用时互相调用，这样有助于后期管理，代码也会更清晰\n概念和第三方库下载 概念 爬虫：简单来说就是一段自动抓取互联网信息的程序，从互联网上抓取对于我们有价值的信息。\n爬虫需要的部分至少有:\n请求部分：获取网页源代码 内容解析部分：通过BeautifulSoup、正则表达式等方法对自己需要的部分进行定位截取 保存部分：可以通过os将爬取到的内容保存至文件夹中 其余的个部分功能基本都是在上述三模块后面进行完善\n第三方库下载 写爬虫时会使用到一些第三方库，这些第三方库不是可以直接调用的\n以Beautiful Soup安装为例： 我们需要打开cmd，进入到 Python（Python2.7版本）安装目录中的 scripts 下，输入 dir 查看是否有 pip.exe, 如果用就可以使用 Python 自带的 pip 命令进行安装，输入以下命令进行安装即可：\n1 pip install beautifulsoup4 也可以在pycharm的终端中直接下载\n测试是否安装成功： 编写一个python文件，输入 1 2 import bs4 print bs4 如果正常输出则安装成功\n数据来源分析 元素审查 打开需要爬取的网页，点击F12进入，点击审查元素按钮，然后将鼠标移动至想检查的位置，这里我看的是新笔趣阁\n检查网页结构 对于爬虫而言，检查网页结构是最为关键的一步，需要对网页进行分析，并找出信息元素的相似性。下面以小说名为例，检查每部影片的 HTML 元素结构，如下所示： 第一本小说名代码如下所示：\n1 2 3 4 5 6 7 8 9 10 \u0026lt;div class=\u0026#34;book-meta\u0026#34;\u0026gt; \u0026lt;h3 class=\u0026#34;book-title\u0026#34;\u0026gt; \u0026lt;span class=\u0026#34;author\u0026#34;\u0026gt;我吃西红柿\u0026lt;/span\u0026gt; \u0026lt;a href=\u0026#34;/book/57929/\u0026#34;\u0026gt;宇宙职业选手\u0026lt;/a\u0026gt; \u0026lt;/h3\u0026gt; \u0026lt;p class=\u0026#34;book-desc\u0026#34;\u0026gt; 2036年，人类第一次登上了荧火星。2052年，第一届世界武道大赛举行，这也是全球最高格斗赛事，全球为之狂热。世界级顶尖选手\u0026#34;枪魔\u0026#34;许景明，于二十六岁那年，...... \u0026lt;/p\u0026gt; \u0026lt;/div\u0026gt; 接下来审查第二本\n1 2 3 4 5 6 7 8 9 10 \u0026lt;div class=\u0026#34;book-meta\u0026#34;\u0026gt; \u0026lt;h3 class=\u0026#34;book-title\u0026#34;\u0026gt; \u0026lt;span class=\u0026#34;author\u0026#34;\u0026gt;耳根\u0026lt;/span\u0026gt; \u0026lt;a href=\u0026#34;/book/107762/\u0026#34;\u0026gt;光阴之外\u0026lt;/a\u0026gt; \u0026lt;/h3\u0026gt; \u0026lt;p class=\u0026#34;book-desc\u0026#34;\u0026gt; 天地是万物众生的客舍，光阴是古往今来的过客。各位书友要是觉得《光阴之外》还不错的话请不要忘记向您QQ群和微博里的朋友推荐哦！光阴之外最新章节地址：...... \u0026lt;/p\u0026gt; \u0026lt;/div\u0026gt; 经过对比发现，每本小说的HTML结构相同，他们的小说名都被\u0026lt;a\u0026gt;标签包裹起来，如果多检查几本的话会发现依旧是这个规律，这样就能继续下一步爬取\n编写爬虫代码 获取了上面的基本网页信息后，就可以进行代码编写了\n(1) 定义请求函数 首先要导入requests库（需要安装），然后使用requests.get方法获取\n为了防止一些网页有反爬，需要将请求头headers进行一下伪装\n最后定义编码格式并进行返回，完整代码如下\n1 2 3 4 5 6 7 8 9 10 11 def get_response(html_url): # 函数参数(html_url)：要请求的链接（url） # 定义请求头 headers = { \u0026#39;User-Agent\u0026#39;: \u0026#39;Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/122.0.0.0 Safari/537.36 Edg/122.0.0.0\u0026#39; } # 获取小说源代码 html_data = requests.get(url=html_url, headers=headers) # 定义编码格式 html_data.encoding = html_data.apparent_encoding # 返回源代码 return html_data 下面进行函数调用检查结果\n1 2 request = get_response(\u0026#34;https://www.xbqg99.cc/\u0026#34;).text print(request) 这里如果不转换为文本格式的话，获取到的是\u0026lt;Response [200]\u0026gt;\n最终获取到的网页结果如下\n出现上述显示证明第一步爬取已经成功\n(2) 获取书名 获取到网站源码以后，接下来姐可以按需要获取所需要的信息了，这里可以选择各种方式，parsrl、正则表达式、BeautifulSoup4等\n根据前面获取到的信息，可以发现书名都在标签下的子级标签中，每本书的a标签都对应着不同的书号，这里我选择用正则表达式进行匹配，首先需要导入正则表达式（re）模块，后续代码写法如下：\n1 r\u0026#39;\u0026lt;dt\u0026gt;.*?\u0026lt;a\\b[^\u0026gt;]*\u0026gt;(.*?)\u0026lt;/a\u0026gt;.*?\u0026lt;/dt\u0026gt;\u0026#39; 其中\n\u0026lt;dt\u0026gt; - 匹配 \u0026lt;dt\u0026gt; 标签\n.*? - 惰性匹配 \u0026lt;dt\u0026gt; 开始标签和 \u0026lt;a\u0026gt; 标签之间的任意内容\n\u0026lt;a\\b[^\u0026gt;]*\u0026gt; - 匹配 \u0026lt;a 及其可能的属性（如 href=\u0026quot;\u0026hellip;\u0026quot;）\n(.*?) - ​​捕获组​​：匹配 \u0026lt;a\u0026gt; 标签内的文本内容\n.*?\u0026lt;/dt\u0026gt; - 惰性匹配 \u0026lt;/a\u0026gt; 和 \u0026lt;/dt\u0026gt; 之间的任意内容，并确保 \u0026lt;/dt\u0026gt; 闭合\n完整函数如下\n1 2 3 4 5 6 def get_data(html_url_2): # 函数参数(html_url_2)： 小说目录页链接 # 获取目录页源代码 html_data = get_response(html_url_2).text # 获取小说名字) name = re.findall(r\u0026#39;\u0026lt;dt\u0026gt;.*?\u0026lt;a\\b[^\u0026gt;]*\u0026gt;(.*?)\u0026lt;/a\u0026gt;.*?\u0026lt;/dt\u0026gt;\u0026#39;, html_data) return name 调用函数并输出结果\n1 2 3 book_name = get_data(\u0026#34;https://www.xbqg99.cc/\u0026#34;) for i in book_name: print(i) 可以看到已经成功爬取到了所有书名\n(3) 将结果保存到本地 获取到书名后，可以将书名存入txt并保存到文本，这里只演示最简单的保存，后续还可以用os等文件夹操作方法将书名存入自定义文件夹\n定义保存函数\n1 2 3 def save(name): with open(\u0026#39;书名.txt\u0026#39;, mode=\u0026#39;a\u0026#39;, encoding=\u0026#39;utf-8\u0026#39;) as f: f.write(name) 短短几行代码就可以将书名保存下来，下面调用函数：\n1 2 3 4 book_name = get_data(\u0026#34;https://www.xbqg99.cc/\u0026#34;) print(book_name) for i in book_name: save(i + \u0026#34;\\n\u0026#34;) 最终结果如下： 这样一个简单的爬虫就写好了，后续还会进行各种研究，之后打算解决各种反爬问题\n","date":"2024-04-15T16:07:59+08:00","image":"https://prts722.github.io/p/%E7%88%AC%E8%99%AB%E5%AD%A6%E4%B9%A01/%E5%B0%81%E9%9D%A2%E5%9B%BE_hu4805807783194955269.png","permalink":"https://prts722.github.io/p/%E7%88%AC%E8%99%AB%E5%AD%A6%E4%B9%A01/","title":"爬虫学习1"},{"content":"","date":"2024-02-10T15:52:23+08:00","image":"https://prts722.github.io/p/%E9%80%9A%E8%BF%87metingjs-aplayer-pjax%E5%BC%95%E5%85%A5%E9%9F%B3%E4%B9%90%E6%92%AD%E6%94%BE%E5%99%A8%E5%B9%B6%E5%AE%9E%E7%8E%B0%E4%B8%8D%E4%B8%AD%E6%96%AD%E5%8A%9F%E8%83%BD/%E5%B0%81%E9%9D%A2%E5%9B%BE_hu8820414483813234051.png","permalink":"https://prts722.github.io/p/%E9%80%9A%E8%BF%87metingjs-aplayer-pjax%E5%BC%95%E5%85%A5%E9%9F%B3%E4%B9%90%E6%92%AD%E6%94%BE%E5%99%A8%E5%B9%B6%E5%AE%9E%E7%8E%B0%E4%B8%8D%E4%B8%AD%E6%96%AD%E5%8A%9F%E8%83%BD/","title":"通过MetingJS+aplayer+Pjax引入音乐播放器并实现不中断功能"},{"content":" 练习了几天基础题后又去简单的算法题练习网站练了练手，突发奇想想将自学的过程记录下来，也方便以后查阅，上网上搜了些教程以后决定搭建个个人博客，最后选择了篇Hugo教程跟着做，目前算是搭建好了，后面可能会美化和部署到github上，不过那都是后话了，等到能在网络上查到那就是成功了嘿嘿。下面正式开始\nHugo下载与安装 前往官网，进入【https://github.com/gohugoio/hugo/tags】，选择最新版本的hugo进行下载并解压 +Windows选择：hugo_extended_xxxxx_windows_amd64.zip\n搭建博客 2.1 创建博客并配置主题 唤起cmd，在命令提示框输入hugo new site 【自定义文件名】创建hugo文件。然后会给出几行命令提示，跟着这几步走便可以搭建好一个博客（因为我这个博客搭建的时候没截图所以借用教程的\u0026hellip;） 图片来源：莱特雷大佬 根据上图提示，开始一步步搭建博客\n敲打命名cd 【自定义文件名】切换目录，并把hugo.exe复制到刚生成的文件夹中 敲打命令hugo server -D启动服务，访问http://localhost:1313，Ctrl+C停止服务，但此时没有任何主题，只会显示page not found，但此时已经成功 2.2 主题配置 (1) 前往Hugo Themes，查找自己喜欢的主题，进行下载 (2) 下载好主题后，将压缩包解压至theme文件夹中 (3) 将exampleSite样例数据中的 Content 和 hugo.yaml 复制到主文件夹中，并删掉hugo.toml和content/post/rich-content (4) 修改 hugo.yaml 中的 theme，将他修改为跟主题文件夹同名 (5) 再次执行hugo server -D命令，可以看到主题已经配置成功 2.3 主题配置修改 不同主题配置文件各有不同，这里我根据自己的主题修改经验，仅记录几个心得和修改方式\n修改前注意，尽量将配置文件写在主文件目录下，hugo是覆盖式，在主文件夹下进行的修改会覆盖主题的配置，这样做方便管理主题\n(1) 语言修改 在主文件夹下的hugo.yaml中可以看到各个样式的配置代码，stack主题默认是英文配置，可以在DefaultContentLanguage中将en改为zh-cn,这样语言就默认为中文主题了(这里我直接偷懒用现在的界面图了)\n(2) 字体修改 在hugo中，作者专门留了assets文件夹用来存放自定义配置文件，下面仅记录字体修改（反正未来没准也能用到其他的）\n前往100font,下载自己想要的字体，将字体文件放入assets/font下（文件夹自己创建）\n将以下代码修改并复制到layouts/partials/footer/custom.html文件中(文件不存在就自己创建)\n字体名：给字体命名一个别名，随便填写就好，保持统一就行 字体文件名：字体文件的全名，带后缀名的，也就是 xxx.ttf 1 2 3 4 5 6 7 8 9 10 11 \u0026lt;style\u0026gt; @font-face { font-family: \u0026#39;字体名\u0026#39;; src: url({{ (resources.Get \u0026#34;font/字体文件名\u0026#34;).Permalink }}) format(\u0026#39;truetype\u0026#39;); } :root { --base-font-family: \u0026#39;字体名\u0026#39;; --code-font-family: \u0026#39;字体名\u0026#39;; } \u0026lt;/style\u0026gt; 这样文字就修改好了\n(3) 时钟组件引入 组件来源 ：莱特雷大佬\n在layouts/partials/widget文件夹下创建clock.html文件（文件夹不存在就自己创建） 将组件中的html、css、script文件放入下面的模板中\n1 2 3 4 5 6 7 8 9 10 11 \u0026lt;div\u0026gt; \u0026lt;!--html内容--\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;script\u0026gt; // script内容 \u0026lt;/script\u0026gt; \u0026lt;style\u0026gt; /* css样式 */ \u0026lt;/style\u0026gt; html内容位置: pure-css3-clock/index.html script内容位置: pure-css3-clock/index.html css样式位置: pure-css3-clock/css/style.css 修改hugo.yaml文件，在params.widgets中添加clock\n最后对样式进行修正优化后，组件就引入成功了\n","date":"2024-02-08T21:58:54+08:00","image":"https://prts722.github.io/p/%E6%8F%92%E6%9B%B2hugo%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2%E6%90%AD%E5%BB%BA/%E5%B0%81%E9%9D%A2%E5%9B%BE_hu7224559985095569437.png","permalink":"https://prts722.github.io/p/%E6%8F%92%E6%9B%B2hugo%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2%E6%90%AD%E5%BB%BA/","title":"【插曲】hugo个人博客搭建"},{"content":" 这一趴记录的是两个无序的数据结构\u0026ndash;字典和元组，字典是这里面最复杂的，因为相比其他三个，字典会含有两个变量而集合和高中数学中的集合就一样了，很好理解\n字典 1.1 介绍和基础用法 字典也是一种可变容器模型，且可存储任意类型对象，含有键(key)值(value)两个变量，和列表相比，列表是有序的对象集合，字典是无序的对象集合。两者之间的区别在于：字典当中的元素是通过键来存取的，而不是通过偏移存取。字典的每个键值 key=\u0026gt;value 对用冒号 : 分割，每个对之间用逗号(,)分割，整个字典包括在花括号 {} 中 ,格式如下所示：\nd = {key1 : value1, key2 : value2, key3 : value3 }\n图片来源:【菜鸟教程】\n键必须是唯一的，但值则不必。值可以取任何数据类型，但键必须是不可变的，如字符串，数字。 创建空字典：\n1 2 emptyDict = {} emptyDict = dict() ## 上下同理，打印结果均是{} 访问字典里的值：\n1 2 3 4 tinydict = {\u0026#39;Name\u0026#39;: \u0026#39;Runoob\u0026#39;, \u0026#39;Age\u0026#39;: 7, \u0026#39;Class\u0026#39;: \u0026#39;First\u0026#39;} print (\u0026#34;tinydict[\u0026#39;Name\u0026#39;]: \u0026#34;, tinydict[\u0026#39;Name\u0026#39;]) print (\u0026#34;tinydict[\u0026#39;Age\u0026#39;]: \u0026#34;, tinydict[\u0026#39;Age\u0026#39;]) 输出结果：\ntinydict[\u0026lsquo;Name\u0026rsquo;]: Runoob\ntinydict[\u0026lsquo;Age\u0026rsquo;]: 7\n如果使用一个不存在的键访问则会报错\n修改字典： 向字典添加新内容的方法是增加新的键/值对，修改或删除已有键/值对\n1 2 3 4 5 6 7 8 tinydict = {\u0026#39;Name\u0026#39;: \u0026#39;Runoob\u0026#39;, \u0026#39;Age\u0026#39;: 7, \u0026#39;Class\u0026#39;: \u0026#39;First\u0026#39;} tinydict[\u0026#39;Age\u0026#39;] = 8 # 更新 Age tinydict[\u0026#39;School\u0026#39;] = \u0026#34;菜鸟教程\u0026#34; # 添加信息 print (\u0026#34;tinydict[\u0026#39;Age\u0026#39;]: \u0026#34;, tinydict[\u0026#39;Age\u0026#39;]) print (\u0026#34;tinydict[\u0026#39;School\u0026#39;]: \u0026#34;, tinydict[\u0026#39;School\u0026#39;]) 输出结果：\ntinydict[\u0026lsquo;Age\u0026rsquo;]: 8\ntinydict[\u0026lsquo;School\u0026rsquo;]: 菜鸟教程\n1.2 内置函数及方法 (记录几个目前常用的函数，以后用到新的再更新，介绍引用自教程)\n函数：\n序号 函数及描述 实例 1 len(dict)`计算字典元素个数，即键的总数。 tinydict ={\u0026lsquo;Name\u0026rsquo;:\u0026lsquo;Runoob\u0026rsquo;, \u0026lsquo;Age\u0026rsquo;: 7, \u0026lsquo;Class\u0026rsquo;: \u0026lsquo;First\u0026rsquo;}\nprint(len(tinydict))\n输出结果3 2 str(dict) 输出字典，可以打印的字符串表示。 tinydict = {\u0026lsquo;Name\u0026rsquo;: \u0026lsquo;Runoob\u0026rsquo;, \u0026lsquo;Age\u0026rsquo;: 7, \u0026lsquo;Class\u0026rsquo;: \u0026lsquo;First\u0026rsquo;}\nprint(str(tinydict))\n输出结果\u0026quot;{\u0026lsquo;Name\u0026rsquo;: \u0026lsquo;Runoob\u0026rsquo;, \u0026lsquo;Class\u0026rsquo;: \u0026lsquo;First\u0026rsquo;, \u0026lsquo;Age\u0026rsquo;: 7}\u0026quot; 3 type(variable) 返回输入的变量类型，\n如果变量是字典就返回字典类型。 tinydict = {\u0026lsquo;Name\u0026rsquo;: \u0026lsquo;Runoob\u0026rsquo;, \u0026lsquo;Age\u0026rsquo;: 7, \u0026lsquo;Class\u0026rsquo;: \u0026lsquo;First\u0026rsquo;}\nprint(type(tinydict))\n输出结果\u0026lt;class \u0026lsquo;dict\u0026rsquo;\u0026gt; 方法：\n序号 函数及描述 1 dict.clear() 删除字典内所有元素 2 dict.copy() 返回一个字典的浅复制 3 dict.get(key, default=None) 返回指定键的值，如果键不在字典中返回 default 设置的默认值 4 key in dict 如果键在字典dict里返回true，否则返回false 5 dict.items() 以列表返回一个视图对象 6 dict.keys() 返回一个视图对象 7 dict.setdefault(key, default=None) 和get()类似, 但如果键不存在于字典中，将会添加键并将值设为default 集合 2.1 介绍和基础用法 集合（Set）是一种无序、可变的数据类型，用于存储唯一的元素。集合中的元素不会重复，并且可以进行交集、并集、差集等常见的集合操作。（高中数学学过..）\n创建集合：\n1 2 parame = {value01,value02,...} set(value) 注意：上面两个创建方法都正确，但是地体个方法使用的是花括号{}，但因为只有一个变量元素所以没有生成字典，而如果用第二个方法则是使用的圆括号set()\n添加元素：\n使用add方法：s.add(x)\n例：\n1 2 3 4 thisset = set((\u0026#34;Google\u0026#34;, \u0026#34;Runoob\u0026#34;, \u0026#34;Taobao\u0026#34;)) thisset.add(\u0026#34;Facebook\u0026#34;) print(thisset) 输出结果：{\u0026#39;Taobao\u0026#39;, \u0026#39;Facebook\u0026#39;, \u0026#39;Google\u0026#39;, \u0026#39;Runoob\u0026#39;} 还有一种方法：s.update( x )\n示例：\n1 2 3 4 5 6 7 thisset = set((\u0026#34;Google\u0026#34;, \u0026#34;Runoob\u0026#34;, \u0026#34;Taobao\u0026#34;)) thisset.update({1,3}) print(thisset) 输出结果：{1, 3, \u0026#39;Google\u0026#39;, \u0026#39;Taobao\u0026#39;, \u0026#39;Runoob\u0026#39;} thisset.update([1,4],[5,6]) print(thisset) 输出结果:{1, 3, 4, 5, 6, \u0026#39;Google\u0026#39;, \u0026#39;Taobao\u0026#39;, \u0026#39;Runoob\u0026#39;} 移除元素语法如下：\ns.remove( x )\n将元素 x 从集合 s 中移除，如果元素不存在，则会发生错误。\n1 2 3 4 5 6 7 8 thisset = set((\u0026#34;Google\u0026#34;, \u0026#34;Runoob\u0026#34;, \u0026#34;Taobao\u0026#34;)) thisset.remove(\u0026#34;Taobao\u0026#34;) print(thisset) 输出 {\u0026#39;Google\u0026#39;, \u0026#39;Runoob\u0026#39;} thisset.remove(\u0026#34;Facebook\u0026#34;) # 不存在会发生错误 Traceback (most recent call last): File \u0026#34;\u0026lt;stdin\u0026gt;\u0026#34;, line 1, in \u0026lt;module\u0026gt; 输出 KeyError: \u0026#39;Facebook\u0026#39; 对我来说使用集合的场景一般在需要去重或者计算数量的时候，为了避免与重复人名导致的数据不准确，这时候用set最为合适，不过也不是完全适用于所有场景，计算元素个数使用len(s)即可\n2.2 内置方法 和之前一样，仅记录已经使用过的方法\n序号 方法 描述 1 add() 为集合添加元素 2 clear() 移除集合中的所有元素 3 copy() 拷贝一个集合 4 difference() 返回多个集合的差集 5 discard() 删除集合中指定的元素 6 intersection() 返回集合的交集 7 intersection_update() 返回集合的交集 8 isdisjoint() 判断两个集合是否包含相同的元素，如果没有返回 True，否则返回 False 9 pop() 随机移除元素 10 remove() 移除指定元素 11 union() 返回两个集合的并集 12 update() 给集合添加元素 13 len() 计算集合元素个数 综上，四大天王算是记录完了，其实说的并不详细，有些还是借用的介绍，但是会用这四个以后真的会有一个很大的提升，无论是对python的理解还是使用，在做几天练习题巩固一下就可以开始试着去研究爬虫了（os：上头了）\n","date":"2024-01-22T11:54:03+08:00","image":"https://prts722.github.io/p/python%E5%9F%BA%E7%A1%80%E5%AD%A6%E4%B9%A03/%E5%B0%81%E9%9D%A2%E5%9B%BE_hu8537297787102080837.png","permalink":"https://prts722.github.io/p/python%E5%9F%BA%E7%A1%80%E5%AD%A6%E4%B9%A03/","title":"Python基础学习3"},{"content":" 复习了几天之前的知识，又加深研究了一下这四大天王，终于是搞懂了，其实分清楚以后就觉得不是很难了\n因为内容有些多所以分两篇文章，为了防止说错，部分内容引用教程\nTips: 列表(list)和元组(tuple)是有序的，字典(dict)和集合(set)是无序的\n列表(list) 1.1 介绍和基础用法 list是一种有序的集合，可以随时添加和删除其中的元素。list可以存储任何类型的对象，整数，字符串，函数等都可以，也可以存储另一个列表。\n可以通过下面两种方法定义一个空列表\n1 2 newList = [] newList = list() 如果定义列表时就需要存储一些对象，只需要填写进去并用逗号隔开即可\n1 a = [1, 2, 3.14, \u0026#39;arknights\u0026#39;] 1.2 索引和切片 和字符串一样，列表也可以被索引访问其中的某个或某些元素，也可以被切片截取\n列表索引方法如下:\n变量[头下标:尾下标]\n索引值以0为开始值，如果从末尾（最右侧）开始，起始值则为-1\n根据左闭右开的原则即可索引需要的部分 图片来源:【菜鸟教程】 列表的切片也和字符串类似，想象用刀去切取其中的一部分，该在哪里下刀，就使用哪里的索引 1 2 3 4 5 6 7 8 9 10 11 a = [1, 2, 3.14, \u0026#39;hello\u0026#39;, [7,8,9] ] a[0:3] # 结果是 [1, 2, 3.14] a[:3] # 结果也是 [1, 2, 3.14] a[3:5] # 结果是 [\u0026#39;hello\u0026#39;, [7,8,9] ] a[3:] # 结果也是 [\u0026#39;hello\u0026#39;, [7,8,9] ] a[-1][:2] # 结果是 [7,8] print(a) # 结果还是 [1, 2, 3.14, \u0026#39;hello\u0026#39;, [7,8,9] ] # 上面对a的切片操作是产生新的对象，并不会改变a指向的对象 上面切片中除了头下标和尾下标，还多了第三个变量，这个变量叫做步长\n[::步长]\n以下实例在索引 1 到索引 4 的位置并设置为步长为 2（间隔一个位置）来截取字符串： 图片来源:【菜鸟教程】\n如果步长为负数则表示逆向读取 1.3 改变列表内容 列表对象有一个特点，它的内容是可以变化的\n比如：\n1 2 3 4 5 a = [1, 2, 3.14, \u0026#39;arknights\u0026#39;, [7,8,9] ] print(a) a[0] = \u0026#39;罗德岛\u0026#39; print(a) 输出结果就变成了\n1 [\u0026#39;罗德岛\u0026#39;, 2, 3.14, \u0026#39;arknights\u0026#39;, [7, 8, 9]] 如果这样写\n1 2 3 4 5 a = [1, 2, 3.14, \u0026#39;arknights\u0026#39;, [7,8,9] ] print(a) a[-1][-1] = \u0026#39;罗德岛\u0026#39; print(a) 就改变了列表里面的列表 的内容，a就变成了\n1 [1, 2, 3.14, \u0026#39;arknights\u0026#39;, [7, 8, \u0026#39;罗德岛\u0026#39;]] 1.4 合并两个列表 列表中要添加另外一个列表的内容很简单，用加号就可以了\n1 2 3 4 5 a = [1,2,3] a += [4,5,6] print(a) ## 输出结果[1, 2, 3, 4, 5, 6] 1.5 列表推导式 根据教程介绍：列表推导式是 Python 中用于创建列表的一种简洁而优雅的方法。通过列表推导式，可以从一个或多个可迭代对象（如列表、元组、字符串、集合等）中生成一个新的列表，同时可以在生成过程中对元素进行过滤和转换。列表推导式不仅能使代码更加简洁，还能提升可读性和执行效率。\n说白了就是将原本的循环判断语法简写，使代码显得更加简洁。基本语法如下：\n[表达式 for 元素 in 可迭代对象 if 条件]\n其中：\n表达式：它是你希望对每个元素进行的操作或转换。 元素：表示当前循环到的元素。 可迭代对象：你要遍历的对象，比如列表、元组、字符串等。 条件（可选）：一个过滤条件，只有满足条件的元素才会被包含在生成的列表中。 元组(tuple) 和列表一样，元组也是有序的，元素之间也用逗号隔开，不同之处在于元组的元素不能修改。元组写在小括号 () 里。\n2.1 基本用法 创建空元组（两种方法）\n1 2 tup1 = () tup1 = tuple() 元组中只包含一个元素时，需要在元素后面添加逗号 , ，否则括号会被当作运算符使用：\n1 2 3 4 5 6 7 tup1 = (50) type(tup1) # 不加逗号，类型为整型 \u0026lt;class \u0026#39;int\u0026#39;\u0026gt; # 输出结果 tup1 = (50,) type(tup1) # 加上逗号，类型为元组 \u0026lt;class \u0026#39;tuple\u0026#39;\u0026gt; # 输出结果 元组中的元素值是不允许删除的，但我们可以使用del语句来删除整个元组，如下实例:\n1 2 3 4 5 6 tup = (\u0026#39;Google\u0026#39;, \u0026#39;Runoob\u0026#39;, 1997, 2000) print (tup) del tup print (\u0026#34;删除后的元组 tup : \u0026#34;) print (tup) 上面实例中的元组被删除后没输出变量会有异常信息，输出如下所示：\nTraceback (most recent call last): File \u0026ldquo;test.py\u0026rdquo;, line 8, in \u0026gt;print (tup) NameError: name \u0026rsquo;tup\u0026rsquo; is not defined\n2.2 索引和切片 因为元组也是一个序列，所以我们可以访问元组中的指定位置的元素，也可以截取索引中的一段元素，即切片\ntup = (\u0026lsquo;Google\u0026rsquo;, \u0026lsquo;Runoob\u0026rsquo;, \u0026lsquo;Taobao\u0026rsquo;, \u0026lsquo;Wiki\u0026rsquo;, \u0026lsquo;Weibo\u0026rsquo;,\u0026lsquo;Weixin\u0026rsquo;)\n图片来源:【菜鸟教程】 2.2 内置函数 元组包含的内置函数如下：\n序号 方法及描述 实例 1 len(tuple) 计算元组元素个数。 tuple1 = (\u0026lsquo;Google\u0026rsquo;, \u0026lsquo;Runoob\u0026rsquo;, \u0026lsquo;Taobao\u0026rsquo;)\nprint(len(tuple1))\n输出结果3 2 max(tuple) 返回元组中元素最大值。 tuple2 = (\u0026lsquo;5\u0026rsquo;, \u0026lsquo;4\u0026rsquo;, \u0026lsquo;8\u0026rsquo;)\nprint(max(tuple2))\n输出结果8 3 min(tuple) 返回元组中元素最小值。 tuple2 = (\u0026lsquo;5\u0026rsquo;, \u0026lsquo;4\u0026rsquo;, \u0026lsquo;8\u0026rsquo;)\nprint(min(tuple2))\n输出结果4 4 tuple(iterable) 将可迭代系列转换为元组。 list1= [\u0026lsquo;Google\u0026rsquo;, \u0026lsquo;Taobao\u0026rsquo;, \u0026lsquo;Runoob\u0026rsquo;, \u0026lsquo;Baidu\u0026rsquo;]\ntuple1=tuple(list1)\nprint(tuple1)\n输出结果(\u0026lsquo;Google\u0026rsquo;, \u0026lsquo;Taobao\u0026rsquo;, \u0026lsquo;Runoob\u0026rsquo;, \u0026lsquo;Baidu\u0026rsquo;) 2.3 “元组是不可变的” 所谓元组的不可变指的是元组所指向的内存中的内容不可变\n1 2 3 4 5 6 7 8 9 10 tup = (\u0026#39;r\u0026#39;, \u0026#39;u\u0026#39;, \u0026#39;n\u0026#39;, \u0026#39;o\u0026#39;, \u0026#39;o\u0026#39;, \u0026#39;b\u0026#39;) tup[0] = \u0026#39;g\u0026#39; # 不支持修改元素 Traceback (most recent call last): File \u0026#34;\u0026lt;stdin\u0026gt;\u0026#34;, line 1, in \u0026lt;module\u0026gt; TypeError: \u0026#39;tuple\u0026#39; object does not support item assignment print(id(tup)) # 查看内存地址 4440687904 #输出结果 tup = (1,2,3) print(id(tup)) 4441088800 # 内存地址不一样了 从以上实例可以看出，重新赋值的元组 tup，绑定到新的对象了，不是修改了原来的对象。\n","date":"2024-01-20T21:05:27+08:00","image":"https://prts722.github.io/p/python%E5%9F%BA%E7%A1%80%E5%AD%A6%E4%B9%A02/%E5%B0%81%E9%9D%A2%E5%9B%BE_hu10746291476206030349.png","permalink":"https://prts722.github.io/p/python%E5%9F%BA%E7%A1%80%E5%AD%A6%E4%B9%A02/","title":"Python基础学习2"},{"content":"小记 使用python前需要下载python和解释器并配置环境变量，下面简单提一下\n下载Python：访问官网 https://www.python.org/downloads/ 自己选择合适版本的Python安装包\n安装Python：运行安装包，记得勾选\u0026quot;Add Python to PATH\u0026quot;选项，这样可以在命令行中直接使用Python\n验证安装：打开命令行（Windows下为cmd，Mac/Linux下为终端），输入python \u0026ndash;version，如果显示Python版本号，说明安装成功\n选择IDE：推荐使用PyCharm或Visual Studio Code作为开发环境，这里我选择的是pycharm\nPython的基础语法及数据类型 2.1 标识符 第一个字符必须以字母（a-z, A-Z）或下划线_组成\n标识符的其他的部分由字母、数字和下划线组成\n标识符对大小写敏感，count 和 Count 是不同的标识符\n标识符对长度无硬性限制，但建议保持简洁（一般不超过 20 个字符）\n禁止使用保留关键字，如 if、for、class 等不能作为标识符\n合法标识符\n1 2 3 4 5 6 7 age = 22 user_name = \u0026#34;斯卡蒂\u0026#34; _total = 100 MAX_SIZE = 1024 calculate_area() StudentInfo __private_var 非法标识符\n1 2 3 4 5 2nd_place = \u0026#34;银灰\u0026#34; # 错误：以数字开头 user-name = \u0026#34;大亚当\u0026#34; # 错误：包含连字符 class = \u0026#34;class\u0026#34; # 错误：使用关键字 $price = 9.99 # 错误：包含特殊字符 for = \u0026#34;loop\u0026#34; # 错误：使用关键字 2.2 基本数据类型 常见的数据类型有以下几种：\nNumber（数字） String（字符串） bool（布尔类型） List（列表） Tuple（元组） Set（集合） Dictionary（字典） 其中数字类型支持int(整型),float(浮点型),bool(布尔型),complex(复数),字符串在使用中用引号\u0026quot; \u0026ldquo;包裹,布尔类型只有两个，为true和false\nList、Tuple、Set、Dictionary比较复杂，会专门写一篇学习记录（绝不是因为还在学习）\n运算符 3.1 算数运算符 尽量全记录下来方便后期查阅使用^^\n算数运算符有以下几种\n运算符 描述 实例 + 加 - 两个对象相加 假设a=10,b=11(下面通用)，a + b 输出结果 21 - 减 - 得到负数或是一个数减去另一个数 a - b 输出结果 -1 * 乘 - 两个数相乘或是返回一个被重复若干次的字符串 a * b 输出结果 110 / 除 - x 除以 y b / a 输出结果 1.1 % 取模 - 返回除法的余数 b % a 输出结果 1 ** 幂 - 返回x的y次幂 a**b 为10的11次方 // 取整除 - 往小的方向取整数 9//2结果为4 (+也可用于字符串之间的连接，和方法.jion()相似)\n3.2 比较运算符 比较运算符有以下几种(假设a为1，b为2)\n运算符 描述 实例 == 等于 - 比较对象是否相等 (a == b) 返回 False ！= 不等于 - 比较两个对象是否不相等 (a != b) 返回 True \u0026gt; 大于 - 返回x是否大于y (a \u0026gt; b) 返回 False \u0026lt; 小于 - 返回x是否小于y。所有比较运算符返回1表示真，返回0表示假。 (a \u0026lt; b) 返回 True \u0026gt;= 大于等于 - 返回x是否大于等于y。 (a \u0026gt;= b) 返回 False \u0026lt;= 小于等于 - 返回x是否小于等于y。 (a \u0026lt;= b) 返回 True (目前来说if判断中用到的多一点)\n3.3 位运算符 位运算符我查了一下，说是按照二进制来计算的，emmm反正会用就行，大致有以下几种(假设a=60，b=13)\n运算符 描述 实例 \u0026amp; 按位与运算符：参与运算的两个值,如果两个相应位都为1,则该位的结果为1,否则为0 (a \u0026amp; b) 输出结果 12 | 按位或运算符：只要对应的二个二进位有一个为1时，结果位就为1 (a | b) 输出结果 61 ^ 按位异或运算符：当两对应的二进位相异时，结果为1 (a ^ b) 输出结果 49 ~ 按位取反运算符：对数据的每个二进制位取反,即把1变为0,把0变为1。\n~x 类似于 -x-1 (~a ) 输出结果 -61 \u0026laquo; 左移动运算符：运算数的各二进位全部左移若干位，由\u0026rdquo;\u0026laquo;\u0026ldquo;右边的数指定移动的位数，高位丢弃，低位补0 a \u0026laquo; 2 输出结果 240 \u0026raquo; 右移动运算符：把\u0026rdquo;\u0026raquo;\u0026ldquo;左边的运算数的各二进位全部右移若干位，\u0026quot;\u0026raquo;\u0026ldquo;右边的数指定移动的位数 a \u0026raquo; 2 输出结果 15 3.4 逻辑运算符 与、或、非（假设a=10，b=20）\n运算符 逻辑表达式 描述 实例 and x and y \u0026ldquo;与\u0026rdquo; - 如果 x 为 False，x and y 返回 x 的值，否则返回 y 的计算值 (a and b) 返回 20 or x or y \u0026ldquo;或\u0026rdquo; - 如果 x 是 True，它返回 x 的值，否则它返回 y 的计算值 (a or b) 返回 10 not not x 布尔\u0026quot;非\u0026rdquo; - 如果 x 为 True，返回 False 。如果 x 为 False，它返回 True not(a and b) 返回 False 3.5 成员运算符and身份运算符 用的不多但是也用过\n运算符 描述 实例 in 如果在指定的序列中找到值返回 True，否则返回 False x 在 y 序列中 , 如果 x 在 y 序列中返回 True not in 如果在指定的序列中没有找到值返回 True，否则返回 False x 不在 y 序列中 , 如果 x 不在 y 序列中返回 True is is 是判断两个标识符是不是引用自一个对象 x is y, 类似 id(x) == id(y) , 如果引用的是同一个对象则返回 True，否则返回 False is not is not 是判断两个标识符是不是引用自不同对象 x is not y ， 类似 id(x) != id(y)。如果引用的不是同一个对象则返回结果 True，否则返回 False 字符串 字符串部分的知识点更多更杂，先记录几个经常用的 假设字符串a为ark，字符串b为nights\n操作符 描述 实例 + 字符串连接（对应的有个方法叫.jion（）也是用来连接字符串的,不过一般作用于列表和元组等） a+b = arknights（） * 重复输出字符串 a*2 输出结果:arkark [ : ] 截取字符串中的一部分，遵循左闭右开原则，例如str[0:2] 是不包含第 3 个字符的 b[1:4] 输出结果 igh % 格式字符串（和.format()一样） 见下面代码 格式化字符串%和.format相似\n% 形式 1 2 3 4 name = \u0026#39;Runoob\u0026#39; \u0026#39;Hello %s\u0026#39; % name 输出\u0026#39;Hello Runoob\u0026#39; .format()形式（f形式） 1 2 3 4 5 6 7 8 9 10 11 12 13 name = \u0026#39;Runoob\u0026#39; f\u0026#39;Hello {name}\u0026#39; # 替换变量 \u0026#39;Hello {}\u0026#39;.format(name) # 同上，上面的是简化写法 输出\u0026#39;Hello Runoob\u0026#39; f\u0026#39;{1+2}\u0026#39; # 使用表达式 输出\u0026#39;3\u0026#39; w = {\u0026#39;name\u0026#39;: \u0026#39;Runoob\u0026#39;, \u0026#39;url\u0026#39;: \u0026#39;www.runoob.com\u0026#39;} f\u0026#39;{w[\u0026#34;name\u0026#34;]}: {w[\u0026#34;url\u0026#34;]}\u0026#39; 输出\u0026#39;Runoob: www.runoob.com\u0026#39; ","date":"2024-01-17T15:02:17+08:00","image":"https://prts722.github.io/p/python%E5%9F%BA%E7%A1%80%E5%AD%A6%E4%B9%A01/%E5%B0%81%E9%9D%A2%E5%9B%BE_hu2253557394020799285.png","permalink":"https://prts722.github.io/p/python%E5%9F%BA%E7%A1%80%E5%AD%A6%E4%B9%A01/","title":"Python基础学习1"}]